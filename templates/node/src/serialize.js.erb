import { Readable } from 'stream'
import * as Node from "./node.js"

import {
  Source,
  Comment,
  MagicComment,
  Location,
  Token,
  ParseResult,
  ParseError,
} from "./source.js"

export class Loader {
  constructor(source, serialized) {
    this.encoding = 'utf8';
    this.input = source.source.slice();
    this.serialized = serialized;

    this.io = new Readable();
    this.io.push(serialized);
    this.io.push(null);
    this.io.setEncoding('binary');

    this.constantPoolOffset = null;
    this.constantPool = null;
    this.source = source;
  }

  loadEncoding() {
    return this.io.read(this.loadVarint());
  }

  loadMetadata() {
    const comments = this.loadVarint();

    const commentsArray = Array(comments).fill().map(() => {
      const type = Comment.TYPES[this.loadVarint()];
      const location = this.loadLocation();

      return new Comment(type, location);
    });

    const magicComments = this.loadVarint();

    const magicCommentsArray = Array(magicComments).fill().map(() => {
      const start = this.loadLocation();
      const end = this.loadLocation();

      return new MagicComment(start, end);
    });

    const errors = this.loadVarint();

    const errorsArray = Array(errors).fill().map(() => {
      const message = this.loadEmbeddedString();
      const location = this.loadLocation();

      return new ParseError(message, location);
    });

    const warnings = this.loadVarint();

    const warningsArray = Array(warnings).fill().map(() => {
      const message = this.loadEmbeddedString();
      const location = this.loadLocation();

      return new ParseWarning(message, location);
    });

    return [
      commentsArray,
      magicCommentsArray,
      errorsArray,
      warningsArray
    ];
  }

  loadTokens() {
    const tokens = [];

    let type;

    while (type = TOKEN_TYPES[this.loadVarint()]) {
      const start = this.loadVarint();
      const length = this.loadVarint();
      const lexState = this.loadVarint();
      const location = new Location(this.source, start, length);

      tokens.push([new Token(type, location.slice(), location), lexState]);
    }

    return tokens;
  }

  loadTokensResult() {
    const tokens = this.loadTokens();
    const encoding = this.loadEncoding();
    const metadata = this.loadMetadata();

    if (encoding !== this.encoding) {
      tokens.forEach(([token]) => token.value = token.value.toString(encoding));
    }

    return new ParseResult(tokens, ...metadata, this.source);
  }

  loadNodes() {
    if (this.io.read(5) !== 'PRISM') throw new Error('Invalid serialization');

    const version = this.io.read(3).split('').map(n => parseInt(n.charCodeAt(0), 10));

    if (version[0] !== Serialize.MAJOR_VERSION || version[1] !== Serialize.MINOR_VERSION || version[2] !== Serialize.PATCH_VERSION) {
      throw new Error('Invalid serialization');
    }

    const onlySemanticFields = this.io.read(1).charCodeAt(0);

    if (onlySemanticFields !== 0) {
      throw new Error('Invalid serialization (location fields must be included but are not)');
    }

    this.encoding = this.loadEncoding();
    this.input = this.input.toString(this.encoding).slice();

    const metadata = this.loadMetadata();

    this.constantPoolOffset = this.io.read(4)
    this.constantPool = Array(this.loadVarint()).fill(null);

    return [this.loadNode(), ...metadata];
  }

  loadResult() {
    const [node, ...metadata] = this.loadNodes();

    return new ParseResult(node, ...metadata, this.source);
  }

  loadVarint() {
    let n = this.io.read(1).charCodeAt(0);

    if (n < 128) return n;
    n -= 128;
    let shift = 0;

    while (true) {
      const b = this.io.read(1).charCodeAt(0);

      if (b >= 128) {
        n += (b - 128) << shift;
        shift += 7;
      } else {
        return n + (b << (shift + 7));
      }
    }
  }

  loadSerializedLength() {
    return this.io.read(4)
  }

  loadOptionalNode() {
    const optionalNode = this.io.read(1)

    if (optionalNode && optionalNode.charCodeAt(0) !== 0) {
      this.io.unshift(optionalNode);

      return this.loadNode();
    }
  }

  loadEmbeddedString() {
    const string = this.io.read(this.loadVarint()).toString(this.encoding)
    console.log(string)
    return string;
  }

  loadString() {
    const type = this.io.read(1).charCodeAt(0);

    if (type === 1) {
      const start = this.loadVarint();
      const length = this.loadVarint();

      return this.input.slice(start, start + length).toString(this.encoding);
    } else if (type === 2) {
      return this.loadEmbeddedString();
    } else {
      throw new Error(`Unknown serialized string type: ${type}`);
    }
  }

  loadLocation() {
    return new Location(this.source, this.loadVarint(), this.loadVarint());
  }

  loadOptionalLocation() {
    const optionalLocation = this.io.read(1)

    if (optionalLocation && optionalLocation.charCodeAt(0) !== 0) {
      this.io.unshift(optionalLocation);

      return this.loadLocation();
    }
  }

  loadConstant(index) {
    let constant = this.constantPool[index];

    if (!constant) {
      const offset = this.constantPoolOffset + index * 8;
      const start = this.serialized.slice(offset);
      const length = this.serialized.slice(offset + 4);

      if (!(start & (1 << 31))) {
        constant = this.input.slice(start, start + length).toString();
      } else {
        constant = this.serialized.slice(start & ((1 << 31) - 1), start & ((1 << 31) - 1) + length).toString();
      }

      this.constantPool[index] = constant;
    }

    return constant;
  }

  loadRequiredConstant() {
    return this.loadConstant(this.loadVarint() - 1)
  }

  loadOptionalConstant() {
    const index = this.loadVarint()

    if (index != 0) {
      return this.loadConstant(index - 1)
    }
  }

  loadNode() {
    const type = this.io.read(1).charCodeAt(0)
    const location = this.loadLocation()

    let node

    switch (type) {
      <%- nodes.each_with_index do |node, index| -%>
      case <%= index + 1 %>:
        <%- if node.needs_serialized_length? -%>
        this.loadSerializedLength()
        <%- end -%>
        node = new Node.<%= node.name %>(<%= (node.fields.map { |field|
          case field
          when Prism::NodeField then "this.loadNode()"
          when Prism::OptionalNodeField then "this.loadOptionalNode()"
          when Prism::StringField then "this.loadString()"
          when Prism::NodeListField then "Array(this.loadVarint()).fill().map(() => this.loadNode())"
          when Prism::ConstantField then "this.loadRequiredConstant()"
          when Prism::OptionalConstantField then "this.loadOptionalConstant()"
          when Prism::ConstantListField then "Array(this.loadVarint()).fill().map(() => this.loadRequiredConstant())"
          when Prism::LocationField then "this.loadLocation()"
          when Prism::OptionalLocationField then "this.loadOptionalLocation()"
          when Prism::UInt32Field, Prism::FlagsField then "this.loadVarint()"
          else raise
          end
      } + ["location"]).join(", ") -%>)
      <%- end -%>
      default:
        throw new Error(`Unknown Node type ${type}`)
    }

    return node
  }
}

const TOKEN_TYPES = [
  null,
  <%- tokens.each do |token| -%>
  <%= token.name.inspect %>,
  <%- end -%>
];

class Leaf {
  constructor(type, location) {
    this.type = type;
    this.location = location;
  }
}

class Arg {
  constructor(name, value) {
    this.name = name;
    this.value = value;
  }
}

class Branch {
  constructor(type, name, args) {
    this.type = type;
    this.name = name;
    this.args = args;
  }
}

export class Serialize {
  static MAJOR_VERSION = 0;
  static MINOR_VERSION = 14;
  static PATCH_VERSION = 0;

  static load(input, serialized) {
    input = input.slice();

    const source = new Source(input);
    const loader = new Loader(source, serialized);
    const result = loader.loadResult();

    input = input.toString(loader.encoding);

    return result;
  }

  static loadTokens(source, serialized) {
    const loader = new Loader(source, serialized);

    return loader.loadTokensResult();
  }
}
