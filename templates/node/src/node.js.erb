export class Node {
  get location() {
    return this.location
  }

  constructor(location) {
    this.location = location;
    this.newline = false;
  }

  newline() {
    return this.newline;
  }

  setNewlineFlag(newlineMarked) {
    const line = this.location.startLine;

    if (!newlineMarked[line]) {
      newlineMarked[line] = true;
      this.newline = true;
    }
  }

  slice() {
    return this.location.slice();
  }

  prettyPrint(q) {
    // TODO: implement
  }

  inspect() {
    // TODO: implement
  }
}

<%- nodes.each do |node| -%>

<%= "#{node.comment.split("\n").map { |line| line.empty? ? "//" : "// #{line}" }.join("\n")}\n" if node.comment %>export class <%= node.name -%> extends Node {
  <%- node.fields.each do |field| -%>
  // attr_reader <%= field.name %>: <%= field.rbs_class %>
  <%= "#" if field.is_a?(Prism::FlagsField) %><%= field.name %>() {
    return this.<%= field.name %>
  }

  <%- end -%>
  // def initialize: (<%= (node.fields.map { |field| "#{field.name}: #{field.rbs_class}" } + ["location: Location"]).join(", ") %>) -> void
  constructor(<%= (node.fields.map(&:name) + ["location"]).join(", ") %>) {
    <%- node.fields.each do |field| -%>
    this.<%= field.name %> = <%= field.name %>
    <%- end -%>
    this.location = location
  }

  // def accept: (visitor: Visitor) -> void
  accept(visitor) {
    this.visitor.visit_<%= node.human %>(this)
  }

  <%- if node.newline == false -%>

  setNewlineFlag(newline_marked) {
    // Never mark <%= node.name %> with a newline flag, mark children instead
  }
  <%- elsif node.newline.is_a?(String) -%>

  setNewlineFlag(newline_marked) {
    <%- field = node.fields.find { |f| f.name == node.newline } or raise node.newline -%>
    <%- case field -%>
    <%- when Prism::NodeField, Prism::OptionalNodeField -%>
    <%= field.name %>.set_newline_flag(newline_marked)
    <%- when Prism::NodeListField -%>
    first = <%= field.name %>.first
    first.set_newline_flag(newline_marked) if first
    <%- else raise field.class.name -%>
    <%- end -%>
  }
  <%- end -%>
  // def child_nodes: () -> Array[nil | Node]
  childNodes() {
    return [<%= node.fields.map { |field|
    case field
    when Prism::NodeField, Prism::OptionalNodeField then "this.#{field.name}"
    when Prism::NodeListField then "...this.#{field.name}"
    end
    }.compact.join(", ") %>]
  }

  // def compact_child_nodes: () -> Array[Node]
  compactChildNodes() {
    <%- if node.fields.any? { |field| field.is_a?(Prism::OptionalNodeField) } -%>
    compact = []

    <%- node.fields.each do |field| -%>
    <%- case field -%>
    <%- when Prism::NodeField -%>
    compact.push(this.<%= field.name %>)

    <%- when Prism::OptionalNodeField -%>
    if (this.<%= field.name %>) {
      compact.push(this.<%= field.name %>)
    }
    <%- when Prism::NodeListField -%>
    compact.concat(this.<%= field.name %>)
    <%- end -%>
    <%- end -%>

    return compact
    <%- else -%>
    return [<%= node.fields.map { |field|
    case field
    when Prism::NodeField then "this.#{field.name}"
    when Prism::NodeListField then "...this.#{field.name}"
    end
    }.compact.join(", ") %>]
    <%- end -%>
  }

  // def comment_targets: () -> Array[Node | Location]
  commentTargets() {
    return [<%= node.fields.map { |field|
    case field
    when Prism::NodeField, Prism::LocationField then "this.#{field.name}"
    when Prism::OptionalNodeField, Prism::NodeListField, Prism::OptionalLocationField then "...this.#{field.name}"
    end
    }.compact.join(", ") %>]
  }

  // def copy: (**params) -> <%= node.name %>
  copy(options = {}) {
    return new <%= node.name %>(
    <%- (node.fields.map(&:name) + ["location"]).map do |name| -%>
      options.<%= name %> || this.<%= name %>,
    <%- end -%>
    )
  }

  // def deconstruct: () -> Array[nil | Node]
  deconstruct() {
    return this.childNodes()
  }

  // def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  deconstructKeys(keys) {
    return {
      <%= (node.fields.map { |field| "#{field.name}: this.#{field.name}" } + ["location: this.location"]).join(", \n      ") %>
    }
  }
  <%- node.fields.each do |field| -%>
  <%- case field -%>
  <%- when Prism::LocationField -%>
  <%- raise unless field.name.end_with?("_loc") -%>
  <%- next if node.fields.any? { |other| other.name == field.name.delete_suffix("_loc") } -%>

  // def <%= field.name.delete_suffix("_loc") %>: () -> String
  <%= field.name.delete_suffix("_loc") %>() {
    return this.<%= field.name %>.slice
  }
  <%- when Prism::OptionalLocationField -%>
  <%- raise unless field.name.end_with?("_loc") -%>
  <%- next if node.fields.any? { |other| other.name == field.name.delete_suffix("_loc") } -%>

  // def <%= field.name.delete_suffix("_loc") %>: () -> String?
  <%= field.name.delete_suffix("_loc") %>() {
    <%= field.name %>?.slice
  }
  <%- when Prism::FlagsField -%>
  <%- flags.find { |flag| flag.name == field.kind }.tap { |flag| raise "Expected to find #{field.kind}" unless flag }.values.each do |value| -%>

  // def <%= value.name.downcase %>?: () -> bool
  get <%= value.name.downcase %>() {
    // TODO: fixme
    // return <%= field.name %>.anybits?(<%= field.kind %>::<%= value.name %>)
  }
  <%- end -%>
  <%- end -%>
  <%- end -%>

  inspect() {
    // TODO: implement
  }

  // Sometimes you want to check an instance of a node against a list of
  // classes to see what kind of behavior to perform. Usually this is done by
  // calling `[cls1, cls2].include?(node.class)` or putting the node into a
  // case statement and doing `case node; when cls1; when cls2; end`. Both of
  // these approaches are relatively slow because of the constant lookups,
  // method calls, and/or array allocations.
  //
  // Instead, you can call #type, which will return to you a symbol that you
  // can use for comparison. This is faster than the other approaches because
  // it uses a single integer comparison, but also because if you're on CRuby
  // you can take advantage of the fact that case statements with all symbol
  // keys will use a jump table.
  //
  // def type: () -> Symbol
  get type() {
    return "<%= node.human %>"
  }

  // Similar to #type, this method returns a symbol that you can use for
  // splitting on the type of the node without having to do a long === chain.
  // Note that like #type, it will still be slower than using == for a single
  // class, but should be faster in a case statement or an array comparison.
  //
  // def self.type: () -> Symbol
  static get type() {
    return "<%= node.human %>"
  }
}

<%- end -%>
<%- flags.each_with_index do |flag, flag_index| -%>

module <%= flag.name %>
  <%- flag.values.each_with_index do |value, index| -%>
  // <%= value.comment %>
  <%= value.name %> = 1 << <%= index %>
<%= "\n" if value != flag.values.last -%>
  <%- end -%>
}
  <%- end -%>
